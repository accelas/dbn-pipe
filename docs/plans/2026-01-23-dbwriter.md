# dbWriter Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a PostgreSQL COPY sink library with compile-time object mapping for streaming market data from dbn-pipe.

**Architecture:** Layered design with Table (schema definition) → Transform (record conversion) → Mapper (binary encoding) → CopyWriter (async libpq). ASIO coroutines for clean async I/O on single connection.

**Tech Stack:** C++20, ASIO (coroutines), libpq, GoogleTest, Bazel

---

## Task 1: Project Structure & Build Setup

**Files:**
- Create: `example/dbwriter/BUILD.bazel`
- Create: `example/dbwriter/include/dbwriter/types.hpp`
- Modify: `MODULE.bazel` (add libpq, asio deps)

**Step 1: Add ASIO and libpq dependencies to MODULE.bazel**

Add after the rapidjson extension:

```python
# ASIO (header-only networking)
asio_ext = use_extension("//third_party/asio:asio.bzl", "asio_ext")
use_repo(asio_ext, "asio")

# libpq (PostgreSQL client)
libpq_ext = use_extension("//third_party/libpq:libpq.bzl", "libpq_ext")
use_repo(libpq_ext, "libpq")
```

**Step 2: Create third_party/asio/asio.bzl**

```python
"""ASIO header-only library."""

def _asio_impl(module_ctx):
    # System ASIO headers
    pass

asio_ext = module_extension(implementation = _asio_impl)
```

**Step 3: Create third_party/asio/BUILD.bazel**

```python
cc_library(
    name = "asio",
    hdrs = glob(["include/**/*.hpp"]),
    includes = ["include"],
    defines = [
        "ASIO_STANDALONE",
        "ASIO_HAS_CO_AWAIT",
    ],
    visibility = ["//visibility:public"],
)
```

**Step 4: Create third_party/libpq/libpq.bzl**

```python
"""System libpq wrapper."""

def _libpq_impl(module_ctx):
    pass

libpq_ext = module_extension(implementation = _libpq_impl)
```

**Step 5: Create third_party/libpq/BUILD.bazel**

```python
cc_library(
    name = "libpq",
    hdrs = ["libpq-fe.h"],
    linkopts = ["-lpq"],
    visibility = ["//visibility:public"],
)
```

**Step 6: Create example/dbwriter/BUILD.bazel**

```python
load("@rules_cc//cc:defs.bzl", "cc_library", "cc_test")

cc_library(
    name = "dbwriter",
    hdrs = glob(["include/dbwriter/*.hpp"]),
    srcs = glob(["src/*.cpp"]),
    includes = ["include"],
    deps = [
        "@asio",
        "@libpq",
    ],
    visibility = ["//visibility:public"],
)

cc_test(
    name = "types_test",
    srcs = ["test/types_test.cpp"],
    deps = [
        ":dbwriter",
        "@googletest//:gtest_main",
    ],
)
```

**Step 7: Create example/dbwriter/include/dbwriter/types.hpp**

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include <cstdint>
#include <span>
#include <string_view>
#include <vector>

namespace dbwriter {

// Timestamp with PostgreSQL epoch (2000-01-01)
struct Timestamp {
    int64_t usec_since_pg_epoch;

    // Convert from Unix nanoseconds to PostgreSQL microseconds
    static Timestamp from_unix_ns(int64_t ns) {
        // Unix epoch: 1970-01-01
        // PG epoch: 2000-01-01
        // Difference: 946684800 seconds = 946684800000000 microseconds
        constexpr int64_t kPgEpochOffsetUsec = 946684800000000LL;
        return Timestamp{ns / 1000 - kPgEpochOffsetUsec};
    }

    int64_t to_pg_timestamp() const { return usec_since_pg_epoch; }
};

// Byte buffer for binary COPY data
class ByteBuffer {
public:
    void put_int16_be(int16_t val);
    void put_int32_be(int32_t val);
    void put_int64_be(int64_t val);
    void put_byte(std::byte b);
    void put_bytes(std::span<const std::byte> data);

    std::span<const std::byte> view() const { return data_; }
    void clear() { data_.clear(); }
    size_t size() const { return data_.size(); }

private:
    std::vector<std::byte> data_;
};

}  // namespace dbwriter
```

**Step 8: Create example/dbwriter/src/types.cpp**

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/types.hpp"
#include <bit>

namespace dbwriter {

void ByteBuffer::put_int16_be(int16_t val) {
    if constexpr (std::endian::native == std::endian::little) {
        val = __builtin_bswap16(val);
    }
    auto* bytes = reinterpret_cast<const std::byte*>(&val);
    data_.insert(data_.end(), bytes, bytes + 2);
}

void ByteBuffer::put_int32_be(int32_t val) {
    if constexpr (std::endian::native == std::endian::little) {
        val = __builtin_bswap32(val);
    }
    auto* bytes = reinterpret_cast<const std::byte*>(&val);
    data_.insert(data_.end(), bytes, bytes + 4);
}

void ByteBuffer::put_int64_be(int64_t val) {
    if constexpr (std::endian::native == std::endian::little) {
        val = __builtin_bswap64(val);
    }
    auto* bytes = reinterpret_cast<const std::byte*>(&val);
    data_.insert(data_.end(), bytes, bytes + 8);
}

void ByteBuffer::put_byte(std::byte b) {
    data_.push_back(b);
}

void ByteBuffer::put_bytes(std::span<const std::byte> data) {
    data_.insert(data_.end(), data.begin(), data.end());
}

}  // namespace dbwriter
```

**Step 9: Create example/dbwriter/test/types_test.cpp**

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/types.hpp"
#include <gtest/gtest.h>

namespace dbwriter {
namespace {

TEST(TimestampTest, FromUnixNs_ConvertsCorrectly) {
    // 2024-01-01 00:00:00 UTC in nanoseconds since Unix epoch
    int64_t unix_ns = 1704067200000000000LL;

    auto ts = Timestamp::from_unix_ns(unix_ns);

    // 2024-01-01 is 24 years after PG epoch (2000-01-01)
    // That's about 757382400 seconds = 757382400000000 usec
    EXPECT_GT(ts.to_pg_timestamp(), 0);
}

TEST(TimestampTest, PgEpoch_IsZero) {
    // 2000-01-01 00:00:00 UTC = 946684800 seconds since Unix epoch
    int64_t pg_epoch_unix_ns = 946684800000000000LL;

    auto ts = Timestamp::from_unix_ns(pg_epoch_unix_ns);

    EXPECT_EQ(ts.to_pg_timestamp(), 0);
}

TEST(ByteBufferTest, PutInt16Be_NetworkByteOrder) {
    ByteBuffer buf;
    buf.put_int16_be(0x0102);

    auto view = buf.view();
    ASSERT_EQ(view.size(), 2);
    EXPECT_EQ(view[0], std::byte{0x01});
    EXPECT_EQ(view[1], std::byte{0x02});
}

TEST(ByteBufferTest, PutInt32Be_NetworkByteOrder) {
    ByteBuffer buf;
    buf.put_int32_be(0x01020304);

    auto view = buf.view();
    ASSERT_EQ(view.size(), 4);
    EXPECT_EQ(view[0], std::byte{0x01});
    EXPECT_EQ(view[1], std::byte{0x02});
    EXPECT_EQ(view[2], std::byte{0x03});
    EXPECT_EQ(view[3], std::byte{0x04});
}

TEST(ByteBufferTest, PutInt64Be_NetworkByteOrder) {
    ByteBuffer buf;
    buf.put_int64_be(0x0102030405060708LL);

    auto view = buf.view();
    ASSERT_EQ(view.size(), 8);
    EXPECT_EQ(view[0], std::byte{0x01});
    EXPECT_EQ(view[7], std::byte{0x08});
}

TEST(ByteBufferTest, Clear_ResetsBuffer) {
    ByteBuffer buf;
    buf.put_int32_be(123);
    EXPECT_EQ(buf.size(), 4);

    buf.clear();

    EXPECT_EQ(buf.size(), 0);
}

}  // namespace
}  // namespace dbwriter
```

**Step 10: Build and run tests**

Run: `bazel test //example/dbwriter:types_test`
Expected: PASS

**Step 11: Commit**

```bash
git add example/dbwriter/ third_party/asio/ third_party/libpq/ MODULE.bazel
git commit -m "feat(dbwriter): add project structure and basic types"
```

---

## Task 2: PostgreSQL Binary Type Encoders

**Files:**
- Create: `example/dbwriter/include/dbwriter/pg_types.hpp`
- Create: `example/dbwriter/test/pg_types_test.cpp`
- Modify: `example/dbwriter/BUILD.bazel`

**Step 1: Write failing tests for binary encoders**

Create `example/dbwriter/test/pg_types_test.cpp`:

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/pg_types.hpp"
#include "dbwriter/types.hpp"
#include <gtest/gtest.h>

namespace dbwriter::pg {
namespace {

TEST(BigIntTest, Encode_WritesLengthAndValue) {
    ByteBuffer buf;
    BigInt::encode(0x0102030405060708LL, buf);

    auto view = buf.view();
    ASSERT_EQ(view.size(), 12);  // 4 (len) + 8 (data)

    // Length = 8 in network byte order
    EXPECT_EQ(view[0], std::byte{0x00});
    EXPECT_EQ(view[1], std::byte{0x00});
    EXPECT_EQ(view[2], std::byte{0x00});
    EXPECT_EQ(view[3], std::byte{0x08});

    // Value in network byte order
    EXPECT_EQ(view[4], std::byte{0x01});
    EXPECT_EQ(view[11], std::byte{0x08});
}

TEST(IntegerTest, Encode_WritesLengthAndValue) {
    ByteBuffer buf;
    Integer::encode(0x01020304, buf);

    auto view = buf.view();
    ASSERT_EQ(view.size(), 8);  // 4 (len) + 4 (data)

    // Length = 4
    EXPECT_EQ(view[3], std::byte{0x04});
    // Value
    EXPECT_EQ(view[4], std::byte{0x01});
}

TEST(SmallIntTest, Encode_WritesLengthAndValue) {
    ByteBuffer buf;
    SmallInt::encode(0x0102, buf);

    auto view = buf.view();
    ASSERT_EQ(view.size(), 6);  // 4 (len) + 2 (data)

    // Length = 2
    EXPECT_EQ(view[3], std::byte{0x02});
}

TEST(CharTest, Encode_WritesSingleByte) {
    ByteBuffer buf;
    Char::encode('A', buf);

    auto view = buf.view();
    ASSERT_EQ(view.size(), 5);  // 4 (len) + 1 (data)

    // Length = 1
    EXPECT_EQ(view[3], std::byte{0x01});
    // Value
    EXPECT_EQ(view[4], std::byte{'A'});
}

TEST(TimestamptzTest, Encode_WritesPgTimestamp) {
    ByteBuffer buf;
    Timestamp ts{123456789LL};  // microseconds since PG epoch
    Timestamptz::encode(ts, buf);

    auto view = buf.view();
    ASSERT_EQ(view.size(), 12);  // 4 (len) + 8 (data)

    // Length = 8
    EXPECT_EQ(view[3], std::byte{0x08});
}

TEST(NullTest, Encode_WritesMinusOne) {
    ByteBuffer buf;
    Null::encode(buf);

    auto view = buf.view();
    ASSERT_EQ(view.size(), 4);

    // -1 in network byte order = 0xFFFFFFFF
    EXPECT_EQ(view[0], std::byte{0xFF});
    EXPECT_EQ(view[1], std::byte{0xFF});
    EXPECT_EQ(view[2], std::byte{0xFF});
    EXPECT_EQ(view[3], std::byte{0xFF});
}

}  // namespace
}  // namespace dbwriter::pg
```

**Step 2: Run tests to verify they fail**

Run: `bazel test //example/dbwriter:pg_types_test`
Expected: FAIL - pg_types.hpp not found

**Step 3: Implement pg_types.hpp**

Create `example/dbwriter/include/dbwriter/pg_types.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include "dbwriter/types.hpp"
#include <cstdint>

namespace dbwriter::pg {

// PostgreSQL BIGINT (8 bytes)
struct BigInt {
    static void encode(int64_t val, ByteBuffer& buf) {
        buf.put_int32_be(8);       // field length
        buf.put_int64_be(val);     // value in network byte order
    }
};

// PostgreSQL INTEGER (4 bytes)
struct Integer {
    static void encode(int32_t val, ByteBuffer& buf) {
        buf.put_int32_be(4);
        buf.put_int32_be(val);
    }
};

// PostgreSQL SMALLINT (2 bytes)
struct SmallInt {
    static void encode(int16_t val, ByteBuffer& buf) {
        buf.put_int32_be(2);
        buf.put_int16_be(val);
    }
};

// PostgreSQL CHAR(1) (1 byte)
struct Char {
    static void encode(char val, ByteBuffer& buf) {
        buf.put_int32_be(1);
        buf.put_byte(static_cast<std::byte>(val));
    }
};

// PostgreSQL TIMESTAMPTZ (8 bytes, microseconds since 2000-01-01)
struct Timestamptz {
    static void encode(Timestamp val, ByteBuffer& buf) {
        buf.put_int32_be(8);
        buf.put_int64_be(val.to_pg_timestamp());
    }
};

// PostgreSQL NULL (-1 length)
struct Null {
    static void encode(ByteBuffer& buf) {
        buf.put_int32_be(-1);
    }
};

// PostgreSQL TEXT (variable length)
struct Text {
    static void encode(std::string_view val, ByteBuffer& buf) {
        buf.put_int32_be(static_cast<int32_t>(val.size()));
        buf.put_bytes({reinterpret_cast<const std::byte*>(val.data()), val.size()});
    }
};

}  // namespace dbwriter::pg
```

**Step 4: Add test target to BUILD.bazel**

Add to `example/dbwriter/BUILD.bazel`:

```python
cc_test(
    name = "pg_types_test",
    srcs = ["test/pg_types_test.cpp"],
    deps = [
        ":dbwriter",
        "@googletest//:gtest_main",
    ],
)
```

**Step 5: Run tests to verify they pass**

Run: `bazel test //example/dbwriter:pg_types_test`
Expected: PASS

**Step 6: Commit**

```bash
git add example/dbwriter/
git commit -m "feat(dbwriter): add PostgreSQL binary type encoders"
```

---

## Task 3: Fixed String Template for Column Names

**Files:**
- Create: `example/dbwriter/include/dbwriter/fixed_string.hpp`
- Create: `example/dbwriter/test/fixed_string_test.cpp`

**Step 1: Write failing test**

Create `example/dbwriter/test/fixed_string_test.cpp`:

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/fixed_string.hpp"
#include <gtest/gtest.h>

namespace dbwriter {
namespace {

TEST(FixedStringTest, ConstructFromLiteral) {
    constexpr FixedString<5> fs{"hello"};
    EXPECT_EQ(fs.view(), "hello");
}

TEST(FixedStringTest, CompileTimeComparison) {
    constexpr FixedString<3> a{"foo"};
    constexpr FixedString<3> b{"foo"};
    constexpr FixedString<3> c{"bar"};

    static_assert(a == b);
    static_assert(a != c);

    EXPECT_EQ(a, b);
    EXPECT_NE(a, c);
}

TEST(FixedStringTest, Size) {
    constexpr FixedString<5> fs{"hello"};
    static_assert(fs.size() == 5);
    EXPECT_EQ(fs.size(), 5);
}

TEST(FixedStringTest, UsableAsTemplateParameter) {
    // This compiles only if FixedString is a valid NTTP
    constexpr auto fs = FixedString{"test"};

    auto get_name = []<FixedString Name>() {
        return Name.view();
    };

    EXPECT_EQ(get_name.template operator()<fs>(), "test");
}

}  // namespace
}  // namespace dbwriter
```

**Step 2: Run test to verify it fails**

Run: `bazel test //example/dbwriter:fixed_string_test`
Expected: FAIL - fixed_string.hpp not found

**Step 3: Implement fixed_string.hpp**

Create `example/dbwriter/include/dbwriter/fixed_string.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include <algorithm>
#include <string_view>

namespace dbwriter {

// Compile-time string for use as template parameter
template <std::size_t N>
struct FixedString {
    char data[N + 1]{};

    constexpr FixedString(const char (&str)[N + 1]) {
        std::copy_n(str, N + 1, data);
    }

    constexpr std::string_view view() const { return {data, N}; }
    constexpr std::size_t size() const { return N; }

    constexpr bool operator==(const FixedString& other) const {
        return view() == other.view();
    }

    constexpr auto operator<=>(const FixedString& other) const {
        return view() <=> other.view();
    }
};

// Deduction guide
template <std::size_t N>
FixedString(const char (&)[N]) -> FixedString<N - 1>;

}  // namespace dbwriter
```

**Step 4: Add test target**

Add to `example/dbwriter/BUILD.bazel`:

```python
cc_test(
    name = "fixed_string_test",
    srcs = ["test/fixed_string_test.cpp"],
    deps = [
        ":dbwriter",
        "@googletest//:gtest_main",
    ],
)
```

**Step 5: Run tests to verify they pass**

Run: `bazel test //example/dbwriter:fixed_string_test`
Expected: PASS

**Step 6: Commit**

```bash
git add example/dbwriter/
git commit -m "feat(dbwriter): add FixedString for compile-time column names"
```

---

## Task 4: Column and Table Schema Definition

**Files:**
- Create: `example/dbwriter/include/dbwriter/table.hpp`
- Create: `example/dbwriter/test/table_test.cpp`

**Step 1: Write failing test**

Create `example/dbwriter/test/table_test.cpp`:

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/table.hpp"
#include "dbwriter/pg_types.hpp"
#include "dbwriter/types.hpp"
#include <gtest/gtest.h>

namespace dbwriter {
namespace {

TEST(ColumnTest, HasNameAndTypes) {
    using Col = Column<"price", int64_t, pg::BigInt>;

    EXPECT_EQ(Col::name.view(), "price");
    static_assert(std::is_same_v<Col::cpp_type, int64_t>);
}

TEST(TableTest, HasNameAndColumns) {
    constexpr auto table = Table{"trades",
        Column<"id", int64_t, pg::BigInt>{},
        Column<"price", int64_t, pg::BigInt>{},
        Column<"size", int32_t, pg::Integer>{},
    };

    EXPECT_EQ(table.name(), "trades");
    EXPECT_EQ(table.column_count(), 3);
}

TEST(TableTest, ColumnNames) {
    constexpr auto table = Table{"test",
        Column<"a", int64_t, pg::BigInt>{},
        Column<"b", int32_t, pg::Integer>{},
    };

    auto names = table.column_names();
    ASSERT_EQ(names.size(), 2);
    EXPECT_EQ(names[0], "a");
    EXPECT_EQ(names[1], "b");
}

TEST(TableTest, RowType_HasNamedMembers) {
    constexpr auto table = Table{"test",
        Column<"id", int64_t, pg::BigInt>{},
        Column<"name", std::string_view, pg::Text>{},
    };

    using Row = decltype(table)::RowType;

    Row row{};
    row.template get<"id">() = 42;
    row.template get<"name">() = "hello";

    EXPECT_EQ(row.template get<"id">(), 42);
    EXPECT_EQ(row.template get<"name">(), "hello");
}

}  // namespace
}  // namespace dbwriter
```

**Step 2: Run test to verify it fails**

Run: `bazel test //example/dbwriter:table_test`
Expected: FAIL - table.hpp not found

**Step 3: Implement table.hpp**

Create `example/dbwriter/include/dbwriter/table.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include "dbwriter/fixed_string.hpp"
#include <array>
#include <string_view>
#include <tuple>

namespace dbwriter {

// Column definition
template <FixedString Name, typename CppType, typename PgType>
struct Column {
    static constexpr auto name = Name;
    using cpp_type = CppType;
    using pg_type = PgType;
};

// Row storage with named access
template <typename... Columns>
class Row {
public:
    using Storage = std::tuple<typename Columns::cpp_type...>;

    template <FixedString Name>
    auto& get() {
        return std::get<index_of<Name>()>(data_);
    }

    template <FixedString Name>
    const auto& get() const {
        return std::get<index_of<Name>()>(data_);
    }

    Storage& as_tuple() { return data_; }
    const Storage& as_tuple() const { return data_; }

private:
    template <FixedString Name, std::size_t I = 0>
    static constexpr std::size_t index_of() {
        if constexpr (I >= sizeof...(Columns)) {
            static_assert(I < sizeof...(Columns), "Column not found");
            return I;
        } else {
            using Col = std::tuple_element_t<I, std::tuple<Columns...>>;
            if constexpr (Col::name == Name) {
                return I;
            } else {
                return index_of<Name, I + 1>();
            }
        }
    }

    Storage data_{};
};

// Table definition
template <FixedString TableName, typename... Columns>
class Table {
public:
    static constexpr std::size_t kColumnCount = sizeof...(Columns);

    constexpr Table(const char*, Columns...) {}

    constexpr std::string_view name() const { return TableName.view(); }
    constexpr std::size_t column_count() const { return kColumnCount; }

    std::array<std::string_view, kColumnCount> column_names() const {
        return {Columns::name.view()...};
    }

    using RowType = Row<Columns...>;
};

// Deduction guide
template <std::size_t N, typename... Columns>
Table(const char (&)[N], Columns...) -> Table<FixedString<N-1>{std::declval<const char(&)[N]>()}, Columns...>;

}  // namespace dbwriter
```

**Step 4: Add test target**

Add to `example/dbwriter/BUILD.bazel`:

```python
cc_test(
    name = "table_test",
    srcs = ["test/table_test.cpp"],
    deps = [
        ":dbwriter",
        "@googletest//:gtest_main",
    ],
)
```

**Step 5: Run tests to verify they pass**

Run: `bazel test //example/dbwriter:table_test`
Expected: PASS

**Step 6: Commit**

```bash
git add example/dbwriter/
git commit -m "feat(dbwriter): add Column and Table schema definitions"
```

---

## Task 5: Mapper - Binary Row Encoding

**Files:**
- Create: `example/dbwriter/include/dbwriter/mapper.hpp`
- Create: `example/dbwriter/test/mapper_test.cpp`

**Step 1: Write failing test**

Create `example/dbwriter/test/mapper_test.cpp`:

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/mapper.hpp"
#include "dbwriter/table.hpp"
#include "dbwriter/pg_types.hpp"
#include "dbwriter/types.hpp"
#include <gtest/gtest.h>

namespace dbwriter {
namespace {

constexpr auto test_table = Table{"test",
    Column<"id", int64_t, pg::BigInt>{},
    Column<"value", int32_t, pg::Integer>{},
};

TEST(MapperTest, EncodeRow_WritesFieldCount) {
    auto mapper = make_mapper(test_table);

    typename decltype(test_table)::RowType row;
    row.get<"id">() = 1;
    row.get<"value">() = 100;

    ByteBuffer buf;
    mapper.encode_row(row, buf);

    auto view = buf.view();
    // First 2 bytes: field count (2) in big-endian
    EXPECT_EQ(view[0], std::byte{0x00});
    EXPECT_EQ(view[1], std::byte{0x02});
}

TEST(MapperTest, EncodeRow_WritesAllFields) {
    auto mapper = make_mapper(test_table);

    typename decltype(test_table)::RowType row;
    row.get<"id">() = 1;
    row.get<"value">() = 100;

    ByteBuffer buf;
    mapper.encode_row(row, buf);

    // 2 (count) + 4+8 (id) + 4+4 (value) = 22 bytes
    EXPECT_EQ(buf.size(), 22);
}

TEST(MapperTest, CopyHeader_WritesMagicAndFlags) {
    auto mapper = make_mapper(test_table);

    ByteBuffer buf;
    mapper.write_copy_header(buf);

    auto view = buf.view();
    // Magic: "PGCOPY\n\377\r\n\0"
    EXPECT_EQ(view[0], std::byte{'P'});
    EXPECT_EQ(view[1], std::byte{'G'});
    EXPECT_EQ(view[5], std::byte{'\n'});
    EXPECT_EQ(view[6], std::byte{0xFF});  // \377
}

TEST(MapperTest, CopyTrailer_WritesMinusOne) {
    auto mapper = make_mapper(test_table);

    ByteBuffer buf;
    mapper.write_copy_trailer(buf);

    auto view = buf.view();
    ASSERT_EQ(view.size(), 2);
    // -1 as int16_t big-endian
    EXPECT_EQ(view[0], std::byte{0xFF});
    EXPECT_EQ(view[1], std::byte{0xFF});
}

}  // namespace
}  // namespace dbwriter
```

**Step 2: Run test to verify it fails**

Run: `bazel test //example/dbwriter:mapper_test`
Expected: FAIL - mapper.hpp not found

**Step 3: Implement mapper.hpp**

Create `example/dbwriter/include/dbwriter/mapper.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include "dbwriter/table.hpp"
#include "dbwriter/types.hpp"
#include <tuple>

namespace dbwriter {

template <typename Table>
class Mapper {
public:
    using RowType = typename Table::RowType;

    explicit Mapper(const Table&) {}

    void encode_row(const RowType& row, ByteBuffer& buf) const {
        // Field count (int16_t)
        buf.put_int16_be(static_cast<int16_t>(Table::kColumnCount));

        // Encode each field
        encode_fields(row, buf, std::make_index_sequence<Table::kColumnCount>{});
    }

    void write_copy_header(ByteBuffer& buf) const {
        // Magic: "PGCOPY\n\377\r\n\0"
        static constexpr std::byte magic[] = {
            std::byte{'P'}, std::byte{'G'}, std::byte{'C'}, std::byte{'O'},
            std::byte{'P'}, std::byte{'Y'}, std::byte{'\n'}, std::byte{0xFF},
            std::byte{'\r'}, std::byte{'\n'}, std::byte{0x00}
        };
        buf.put_bytes(magic);

        // Flags (4 bytes, 0 for no OIDs)
        buf.put_int32_be(0);

        // Extension area length (4 bytes, 0)
        buf.put_int32_be(0);
    }

    void write_copy_trailer(ByteBuffer& buf) const {
        // -1 as int16_t signals end of data
        buf.put_int16_be(-1);
    }

private:
    template <std::size_t... Is>
    void encode_fields(const RowType& row, ByteBuffer& buf,
                       std::index_sequence<Is...>) const {
        (encode_field<Is>(row, buf), ...);
    }

    template <std::size_t I>
    void encode_field(const RowType& row, ByteBuffer& buf) const {
        using Columns = typename RowType::Storage;
        using ColType = std::tuple_element_t<I, Columns>;
        // Get the PgType from the Table's column list
        // For now, use the value directly
        const auto& value = std::get<I>(row.as_tuple());

        // This requires knowing the PgType - we need to enhance Table
        // For now, use size-based dispatch
        if constexpr (sizeof(ColType) == 8) {
            buf.put_int32_be(8);
            buf.put_int64_be(static_cast<int64_t>(value));
        } else if constexpr (sizeof(ColType) == 4) {
            buf.put_int32_be(4);
            buf.put_int32_be(static_cast<int32_t>(value));
        } else if constexpr (sizeof(ColType) == 2) {
            buf.put_int32_be(2);
            buf.put_int16_be(static_cast<int16_t>(value));
        } else if constexpr (sizeof(ColType) == 1) {
            buf.put_int32_be(1);
            buf.put_byte(static_cast<std::byte>(value));
        }
    }
};

template <typename Table>
Mapper<Table> make_mapper(const Table& table) {
    return Mapper<Table>(table);
}

}  // namespace dbwriter
```

**Step 4: Add test target**

Add to `example/dbwriter/BUILD.bazel`:

```python
cc_test(
    name = "mapper_test",
    srcs = ["test/mapper_test.cpp"],
    deps = [
        ":dbwriter",
        "@googletest//:gtest_main",
    ],
)
```

**Step 5: Run tests to verify they pass**

Run: `bazel test //example/dbwriter:mapper_test`
Expected: PASS

**Step 6: Commit**

```bash
git add example/dbwriter/
git commit -m "feat(dbwriter): add Mapper for binary row encoding"
```

---

## Task 6: Database Interface

**Files:**
- Create: `example/dbwriter/include/dbwriter/database.hpp`
- Create: `example/dbwriter/test/mock_database.hpp`

**Step 1: Create database interface**

Create `example/dbwriter/include/dbwriter/database.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include <asio/awaitable.hpp>
#include <memory>
#include <optional>
#include <span>
#include <string>
#include <string_view>
#include <vector>

namespace dbwriter {

// Query result row
class IRow {
public:
    virtual ~IRow() = default;

    virtual int64_t get_int64(std::size_t col) const = 0;
    virtual int32_t get_int32(std::size_t col) const = 0;
    virtual std::string_view get_string(std::size_t col) const = 0;
    virtual bool is_null(std::size_t col) const = 0;
};

// Query result set
class QueryResult {
public:
    QueryResult() = default;
    explicit QueryResult(std::vector<std::unique_ptr<IRow>> rows)
        : rows_(std::move(rows)) {}

    bool empty() const { return rows_.empty(); }
    std::size_t size() const { return rows_.size(); }

    const IRow& operator[](std::size_t i) const { return *rows_[i]; }

    auto begin() const { return rows_.begin(); }
    auto end() const { return rows_.end(); }

private:
    std::vector<std::unique_ptr<IRow>> rows_;
};

// COPY writer interface
class ICopyWriter {
public:
    virtual ~ICopyWriter() = default;

    virtual asio::awaitable<void> start() = 0;
    virtual asio::awaitable<void> write_row(std::span<const std::byte> data) = 0;
    virtual asio::awaitable<void> finish() = 0;
    virtual asio::awaitable<void> abort() = 0;
};

// Database interface
class IDatabase {
public:
    virtual ~IDatabase() = default;

    virtual asio::awaitable<QueryResult> query(std::string_view sql) = 0;
    virtual asio::awaitable<void> execute(std::string_view sql) = 0;

    virtual std::unique_ptr<ICopyWriter> begin_copy(
        std::string_view table,
        std::span<const std::string_view> columns) = 0;

    virtual bool is_connected() const = 0;
};

}  // namespace dbwriter
```

**Step 2: Create mock for testing**

Create `example/dbwriter/test/mock_database.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include "dbwriter/database.hpp"
#include <gmock/gmock.h>

namespace dbwriter::testing {

class MockRow : public IRow {
public:
    MOCK_METHOD(int64_t, get_int64, (std::size_t), (const, override));
    MOCK_METHOD(int32_t, get_int32, (std::size_t), (const, override));
    MOCK_METHOD(std::string_view, get_string, (std::size_t), (const, override));
    MOCK_METHOD(bool, is_null, (std::size_t), (const, override));
};

class MockCopyWriter : public ICopyWriter {
public:
    MOCK_METHOD(asio::awaitable<void>, start, (), (override));
    MOCK_METHOD(asio::awaitable<void>, write_row, (std::span<const std::byte>), (override));
    MOCK_METHOD(asio::awaitable<void>, finish, (), (override));
    MOCK_METHOD(asio::awaitable<void>, abort, (), (override));

    std::vector<std::vector<std::byte>> captured_rows;
};

class MockDatabase : public IDatabase {
public:
    MOCK_METHOD(asio::awaitable<QueryResult>, query, (std::string_view), (override));
    MOCK_METHOD(asio::awaitable<void>, execute, (std::string_view), (override));
    MOCK_METHOD(std::unique_ptr<ICopyWriter>, begin_copy,
        (std::string_view, std::span<const std::string_view>), (override));
    MOCK_METHOD(bool, is_connected, (), (const, override));
};

}  // namespace dbwriter::testing
```

**Step 3: Commit**

```bash
git add example/dbwriter/
git commit -m "feat(dbwriter): add IDatabase interface and mocks"
```

---

## Task 7: Transform Layer

**Files:**
- Create: `example/dbwriter/include/dbwriter/transform.hpp`
- Create: `example/dbwriter/test/transform_test.cpp`

**Step 1: Write failing test**

Create `example/dbwriter/test/transform_test.cpp`:

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/transform.hpp"
#include "dbwriter/table.hpp"
#include "dbwriter/pg_types.hpp"
#include <gtest/gtest.h>
#include <gmock/gmock.h>

namespace dbwriter {
namespace {

// Mock instrument map
class MockInstrumentMap : public IInstrumentMap {
public:
    MOCK_METHOD(std::optional<uint32_t>, underlying, (uint32_t), (const, override));
};

// Sample source record
struct TradeRecord {
    int64_t ts_event_ns;
    int32_t instrument_id;
    int64_t price;
    int32_t size;
};

// Target table
constexpr auto trades_table = Table{"trades",
    Column<"ts_event_ns", int64_t, pg::BigInt>{},
    Column<"ts_event", Timestamp, pg::Timestamptz>{},
    Column<"instrument_id", int32_t, pg::Integer>{},
    Column<"underlying_id", int32_t, pg::Integer>{},
    Column<"price", int64_t, pg::BigInt>{},
    Column<"size", int32_t, pg::Integer>{},
};

using TradesRow = decltype(trades_table)::RowType;

// Transform specialization
template <>
struct Transform<TradeRecord, decltype(trades_table)> {
    const IInstrumentMap& instruments;

    TradesRow operator()(const TradeRecord& rec) const {
        TradesRow row;
        row.get<"ts_event_ns">() = rec.ts_event_ns;
        row.get<"ts_event">() = Timestamp::from_unix_ns(rec.ts_event_ns);
        row.get<"instrument_id">() = rec.instrument_id;
        row.get<"underlying_id">() = instruments.underlying(rec.instrument_id).value_or(0);
        row.get<"price">() = rec.price;
        row.get<"size">() = rec.size;
        return row;
    }
};

TEST(TransformTest, TransformsBasicFields) {
    MockInstrumentMap instruments;
    EXPECT_CALL(instruments, underlying(1234))
        .WillOnce(::testing::Return(std::optional<uint32_t>{5678}));

    Transform<TradeRecord, decltype(trades_table)> transform{instruments};

    TradeRecord rec{
        .ts_event_ns = 1704067200000000000LL,
        .instrument_id = 1234,
        .price = 150'000'000'000LL,
        .size = 100,
    };

    auto row = transform(rec);

    EXPECT_EQ(row.get<"ts_event_ns">(), 1704067200000000000LL);
    EXPECT_EQ(row.get<"instrument_id">(), 1234);
    EXPECT_EQ(row.get<"underlying_id">(), 5678);
    EXPECT_EQ(row.get<"price">(), 150'000'000'000LL);
    EXPECT_EQ(row.get<"size">(), 100);
}

TEST(TransformTest, DerivesTimestamp) {
    MockInstrumentMap instruments;
    EXPECT_CALL(instruments, underlying(::testing::_))
        .WillRepeatedly(::testing::Return(std::optional<uint32_t>{0}));

    Transform<TradeRecord, decltype(trades_table)> transform{instruments};

    // PG epoch: 2000-01-01 00:00:00 UTC
    int64_t pg_epoch_ns = 946684800000000000LL;

    TradeRecord rec{.ts_event_ns = pg_epoch_ns};
    auto row = transform(rec);

    // ts_event should be 0 (PG epoch)
    EXPECT_EQ(row.get<"ts_event">().to_pg_timestamp(), 0);
}

TEST(TransformTest, LookupFailure_ReturnsZero) {
    MockInstrumentMap instruments;
    EXPECT_CALL(instruments, underlying(9999))
        .WillOnce(::testing::Return(std::nullopt));

    Transform<TradeRecord, decltype(trades_table)> transform{instruments};

    TradeRecord rec{.instrument_id = 9999};
    auto row = transform(rec);

    EXPECT_EQ(row.get<"underlying_id">(), 0);
}

}  // namespace
}  // namespace dbwriter
```

**Step 2: Run test to verify it fails**

Run: `bazel test //example/dbwriter:transform_test`
Expected: FAIL - transform.hpp not found

**Step 3: Implement transform.hpp**

Create `example/dbwriter/include/dbwriter/transform.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include <cstdint>
#include <optional>

namespace dbwriter {

// Instrument map interface for underlying lookups
class IInstrumentMap {
public:
    virtual ~IInstrumentMap() = default;
    virtual std::optional<uint32_t> underlying(uint32_t instrument_id) const = 0;
};

// Transform template - specialize for each Record → Table mapping
template <typename Record, typename Table>
struct Transform {
    // Specializations must provide:
    // - const IInstrumentMap& instruments (or other dependencies)
    // - RowType operator()(const Record&) const
};

}  // namespace dbwriter
```

**Step 4: Add test target**

Add to `example/dbwriter/BUILD.bazel`:

```python
cc_test(
    name = "transform_test",
    srcs = ["test/transform_test.cpp"],
    deps = [
        ":dbwriter",
        "@googletest//:gtest_main",
    ],
)
```

**Step 5: Run tests to verify they pass**

Run: `bazel test //example/dbwriter:transform_test`
Expected: PASS

**Step 6: Commit**

```bash
git add example/dbwriter/
git commit -m "feat(dbwriter): add Transform layer for record conversion"
```

---

## Task 8: PostgreSQL CopyWriter Implementation

**Files:**
- Create: `example/dbwriter/include/dbwriter/postgres.hpp`
- Create: `example/dbwriter/src/postgres.cpp`
- Create: `example/dbwriter/test/postgres_test.cpp`

**Step 1: Write failing test (mock-based)**

Create `example/dbwriter/test/postgres_test.cpp`:

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/postgres.hpp"
#include <gtest/gtest.h>

namespace dbwriter {
namespace {

// Note: Full integration tests require a real PostgreSQL connection
// These tests verify the interface and mock behavior

TEST(PostgresCopyWriterTest, ConstructsWithConnection) {
    // This test just verifies compilation
    // Real tests would use testcontainers
    SUCCEED();
}

TEST(PostgresDatabaseTest, ConnectionString) {
    PostgresConfig config{
        .host = "localhost",
        .port = 5432,
        .database = "test",
        .user = "user",
        .password = "pass",
    };

    auto conn_str = config.connection_string();

    EXPECT_NE(conn_str.find("host=localhost"), std::string::npos);
    EXPECT_NE(conn_str.find("port=5432"), std::string::npos);
    EXPECT_NE(conn_str.find("dbname=test"), std::string::npos);
}

}  // namespace
}  // namespace dbwriter
```

**Step 2: Implement postgres.hpp**

Create `example/dbwriter/include/dbwriter/postgres.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include "dbwriter/database.hpp"
#include <libpq-fe.h>
#include <asio.hpp>
#include <memory>
#include <string>

namespace dbwriter {

struct PostgresConfig {
    std::string host = "localhost";
    int port = 5432;
    std::string database;
    std::string user;
    std::string password;

    std::string connection_string() const;
};

class PostgresCopyWriter : public ICopyWriter {
public:
    PostgresCopyWriter(PGconn* conn, asio::io_context& ctx,
                       std::string_view table,
                       std::span<const std::string_view> columns);
    ~PostgresCopyWriter();

    asio::awaitable<void> start() override;
    asio::awaitable<void> write_row(std::span<const std::byte> data) override;
    asio::awaitable<void> finish() override;
    asio::awaitable<void> abort() override;

private:
    asio::awaitable<void> wait_writable();
    asio::awaitable<void> send_data(std::span<const std::byte> data);

    PGconn* conn_;
    asio::posix::stream_descriptor socket_;
    std::string table_;
    std::vector<std::string> columns_;
    bool in_copy_ = false;
};

class PostgresDatabase : public IDatabase {
public:
    PostgresDatabase(asio::io_context& ctx, const PostgresConfig& config);
    ~PostgresDatabase();

    asio::awaitable<void> connect();

    asio::awaitable<QueryResult> query(std::string_view sql) override;
    asio::awaitable<void> execute(std::string_view sql) override;

    std::unique_ptr<ICopyWriter> begin_copy(
        std::string_view table,
        std::span<const std::string_view> columns) override;

    bool is_connected() const override;

private:
    asio::io_context& ctx_;
    PostgresConfig config_;
    PGconn* conn_ = nullptr;
};

}  // namespace dbwriter
```

**Step 3: Implement postgres.cpp**

Create `example/dbwriter/src/postgres.cpp`:

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/postgres.hpp"
#include <sstream>
#include <stdexcept>

namespace dbwriter {

std::string PostgresConfig::connection_string() const {
    std::ostringstream ss;
    ss << "host=" << host
       << " port=" << port
       << " dbname=" << database
       << " user=" << user
       << " password=" << password;
    return ss.str();
}

// PostgresCopyWriter implementation

PostgresCopyWriter::PostgresCopyWriter(
    PGconn* conn, asio::io_context& ctx,
    std::string_view table,
    std::span<const std::string_view> columns)
    : conn_(conn)
    , socket_(ctx, PQsocket(conn))
    , table_(table) {
    for (const auto& col : columns) {
        columns_.emplace_back(col);
    }
}

PostgresCopyWriter::~PostgresCopyWriter() {
    if (in_copy_) {
        // Best effort abort
        PQputCopyEnd(conn_, "aborted");
        PQgetResult(conn_);
    }
}

asio::awaitable<void> PostgresCopyWriter::start() {
    // Build COPY command
    std::ostringstream ss;
    ss << "COPY " << table_ << " (";
    for (size_t i = 0; i < columns_.size(); ++i) {
        if (i > 0) ss << ", ";
        ss << columns_[i];
    }
    ss << ") FROM STDIN WITH (FORMAT binary)";

    // Send command
    if (!PQsendQuery(conn_, ss.str().c_str())) {
        throw std::runtime_error(PQerrorMessage(conn_));
    }

    // Wait for result
    co_await wait_writable();

    PGresult* res = PQgetResult(conn_);
    if (PQresultStatus(res) != PGRES_COPY_IN) {
        std::string err = PQresultErrorMessage(res);
        PQclear(res);
        throw std::runtime_error("COPY failed: " + err);
    }
    PQclear(res);

    in_copy_ = true;

    // Write binary COPY header
    static constexpr char header[] = "PGCOPY\n\377\r\n\0\0\0\0\0\0\0\0\0";
    co_await send_data({reinterpret_cast<const std::byte*>(header), 19});
}

asio::awaitable<void> PostgresCopyWriter::write_row(std::span<const std::byte> data) {
    co_await send_data(data);
}

asio::awaitable<void> PostgresCopyWriter::finish() {
    // Write trailer (-1 as int16)
    static constexpr char trailer[] = "\xFF\xFF";
    co_await send_data({reinterpret_cast<const std::byte*>(trailer), 2});

    // End COPY
    if (PQputCopyEnd(conn_, nullptr) != 1) {
        throw std::runtime_error(PQerrorMessage(conn_));
    }

    in_copy_ = false;

    // Get result
    PGresult* res = PQgetResult(conn_);
    if (PQresultStatus(res) != PGRES_COMMAND_OK) {
        std::string err = PQresultErrorMessage(res);
        PQclear(res);
        throw std::runtime_error("COPY finish failed: " + err);
    }
    PQclear(res);

    co_return;
}

asio::awaitable<void> PostgresCopyWriter::abort() {
    if (in_copy_) {
        PQputCopyEnd(conn_, "aborted by client");
        PQgetResult(conn_);
        in_copy_ = false;
    }
    co_return;
}

asio::awaitable<void> PostgresCopyWriter::wait_writable() {
    co_await socket_.async_wait(
        asio::posix::stream_descriptor::wait_write,
        asio::use_awaitable);
}

asio::awaitable<void> PostgresCopyWriter::send_data(std::span<const std::byte> data) {
    int result = PQputCopyData(conn_,
        reinterpret_cast<const char*>(data.data()),
        static_cast<int>(data.size()));

    if (result == -1) {
        throw std::runtime_error(PQerrorMessage(conn_));
    }

    if (result == 0) {
        // Would block, wait for writable
        co_await wait_writable();
        // Retry
        result = PQputCopyData(conn_,
            reinterpret_cast<const char*>(data.data()),
            static_cast<int>(data.size()));
        if (result != 1) {
            throw std::runtime_error(PQerrorMessage(conn_));
        }
    }

    co_return;
}

// PostgresDatabase implementation

PostgresDatabase::PostgresDatabase(asio::io_context& ctx, const PostgresConfig& config)
    : ctx_(ctx)
    , config_(config) {}

PostgresDatabase::~PostgresDatabase() {
    if (conn_) {
        PQfinish(conn_);
    }
}

asio::awaitable<void> PostgresDatabase::connect() {
    conn_ = PQconnectdb(config_.connection_string().c_str());

    if (PQstatus(conn_) != CONNECTION_OK) {
        std::string err = PQerrorMessage(conn_);
        PQfinish(conn_);
        conn_ = nullptr;
        throw std::runtime_error("Connection failed: " + err);
    }

    // Set non-blocking mode
    PQsetnonblocking(conn_, 1);

    co_return;
}

asio::awaitable<QueryResult> PostgresDatabase::query(std::string_view sql) {
    if (!PQsendQuery(conn_, std::string(sql).c_str())) {
        throw std::runtime_error(PQerrorMessage(conn_));
    }

    // Wait for result (simplified - real impl would use async)
    PGresult* res = PQgetResult(conn_);
    if (PQresultStatus(res) != PGRES_TUPLES_OK) {
        std::string err = PQresultErrorMessage(res);
        PQclear(res);
        throw std::runtime_error("Query failed: " + err);
    }

    // Convert to QueryResult (simplified)
    PQclear(res);
    co_return QueryResult{};
}

asio::awaitable<void> PostgresDatabase::execute(std::string_view sql) {
    if (!PQsendQuery(conn_, std::string(sql).c_str())) {
        throw std::runtime_error(PQerrorMessage(conn_));
    }

    PGresult* res = PQgetResult(conn_);
    if (PQresultStatus(res) != PGRES_COMMAND_OK) {
        std::string err = PQresultErrorMessage(res);
        PQclear(res);
        throw std::runtime_error("Execute failed: " + err);
    }
    PQclear(res);

    co_return;
}

std::unique_ptr<ICopyWriter> PostgresDatabase::begin_copy(
    std::string_view table,
    std::span<const std::string_view> columns) {
    return std::make_unique<PostgresCopyWriter>(conn_, ctx_, table, columns);
}

bool PostgresDatabase::is_connected() const {
    return conn_ && PQstatus(conn_) == CONNECTION_OK;
}

}  // namespace dbwriter
```

**Step 4: Add test target**

Add to `example/dbwriter/BUILD.bazel`:

```python
cc_test(
    name = "postgres_test",
    srcs = ["test/postgres_test.cpp"],
    deps = [
        ":dbwriter",
        "@googletest//:gtest_main",
    ],
)
```

**Step 5: Run tests**

Run: `bazel test //example/dbwriter:postgres_test`
Expected: PASS

**Step 6: Commit**

```bash
git add example/dbwriter/
git commit -m "feat(dbwriter): add PostgreSQL CopyWriter implementation"
```

---

## Task 9: BatchWriter with Backpressure

**Files:**
- Create: `example/dbwriter/include/dbwriter/batch_writer.hpp`
- Create: `example/dbwriter/src/batch_writer.cpp`
- Create: `example/dbwriter/test/batch_writer_test.cpp`

**Step 1: Write failing test**

Create `example/dbwriter/test/batch_writer_test.cpp`:

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/batch_writer.hpp"
#include "test/mock_database.hpp"
#include <gtest/gtest.h>
#include <gmock/gmock.h>

namespace dbwriter {
namespace {

using ::testing::_;
using ::testing::Return;

TEST(BackpressureConfigTest, Defaults) {
    BackpressureConfig config;

    EXPECT_EQ(config.max_pending_bytes, 1ULL * 1024 * 1024 * 1024);
    EXPECT_EQ(config.high_water_mark, 256);
    EXPECT_EQ(config.low_water_mark, 64);
}

TEST(BatchWriterTest, EnqueueBatch_IncrementsQueueSize) {
    // This tests queue behavior - full test needs async context
    SUCCEED();
}

}  // namespace
}  // namespace dbwriter
```

**Step 2: Implement batch_writer.hpp**

Create `example/dbwriter/include/dbwriter/batch_writer.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include "dbwriter/database.hpp"
#include "dbwriter/mapper.hpp"
#include "dbwriter/transform.hpp"
#include "dbwriter/types.hpp"
#include <asio.hpp>
#include <deque>
#include <functional>
#include <span>
#include <vector>

namespace dbwriter {

struct BackpressureConfig {
    size_t max_pending_bytes = 1ULL * 1024 * 1024 * 1024;  // 1GB
    size_t high_water_mark = 256;
    size_t low_water_mark = 64;
};

enum class WriteError {
    ConnectionLost,
    CopyFailed,
    SerializationError,
    Timeout,
};

// Suspendable interface for backpressure
class ISuspendable {
public:
    virtual ~ISuspendable() = default;
    virtual void Suspend() = 0;
    virtual void Resume() = 0;
};

template <typename Record, typename Table, typename TransformT>
class BatchWriter {
public:
    using RowType = typename Table::RowType;
    using ErrorHandler = std::function<void(WriteError, std::string_view)>;

    BatchWriter(asio::io_context& ctx,
                IDatabase& db,
                const Table& table,
                TransformT transform,
                BackpressureConfig config = {})
        : ctx_(ctx)
        , db_(db)
        , table_(table)
        , transform_(std::move(transform))
        , mapper_(table)
        , config_(config) {}

    void set_suspendable(ISuspendable* s) { suspendable_ = s; }
    void on_error(ErrorHandler handler) { error_handler_ = std::move(handler); }

    void enqueue(std::vector<Record> batch) {
        pending_batches_.push_back(std::move(batch));
        check_backpressure();

        if (!writing_) {
            asio::co_spawn(ctx_, process_queue(), asio::detached);
        }
    }

    size_t pending_count() const { return pending_batches_.size(); }

private:
    asio::awaitable<void> process_queue() {
        writing_ = true;

        while (!pending_batches_.empty()) {
            auto batch = std::move(pending_batches_.front());
            pending_batches_.pop_front();

            try {
                co_await write_batch(batch);
            } catch (const std::exception& e) {
                if (error_handler_) {
                    error_handler_(WriteError::CopyFailed, e.what());
                }
            }

            check_resume();
        }

        writing_ = false;
    }

    asio::awaitable<void> write_batch(const std::vector<Record>& batch) {
        auto columns = table_.column_names();
        std::vector<std::string_view> col_views(columns.begin(), columns.end());

        auto writer = db_.begin_copy(table_.name(), col_views);

        co_await writer->start();

        ByteBuffer buf;
        for (const auto& record : batch) {
            auto row = transform_(record);
            mapper_.encode_row(row, buf);
            co_await writer->write_row(buf.view());
            buf.clear();
        }

        co_await writer->finish();
    }

    void check_backpressure() {
        if (suspendable_ && pending_batches_.size() > config_.high_water_mark) {
            suspendable_->Suspend();
            suspended_ = true;
        }
    }

    void check_resume() {
        if (suspendable_ && suspended_ &&
            pending_batches_.size() < config_.low_water_mark) {
            suspendable_->Resume();
            suspended_ = false;
        }
    }

    asio::io_context& ctx_;
    IDatabase& db_;
    const Table& table_;
    TransformT transform_;
    Mapper<Table> mapper_;
    BackpressureConfig config_;

    std::deque<std::vector<Record>> pending_batches_;
    bool writing_ = false;
    bool suspended_ = false;
    ISuspendable* suspendable_ = nullptr;
    ErrorHandler error_handler_;
};

}  // namespace dbwriter
```

**Step 3: Add test target**

Add to `example/dbwriter/BUILD.bazel`:

```python
cc_test(
    name = "batch_writer_test",
    srcs = ["test/batch_writer_test.cpp"],
    deps = [
        ":dbwriter",
        "@googletest//:gtest_main",
    ],
)
```

**Step 4: Run tests**

Run: `bazel test //example/dbwriter:batch_writer_test`
Expected: PASS

**Step 5: Commit**

```bash
git add example/dbwriter/
git commit -m "feat(dbwriter): add BatchWriter with backpressure"
```

---

## Task 10: Schema Validator

**Files:**
- Create: `example/dbwriter/include/dbwriter/schema_validator.hpp`
- Create: `example/dbwriter/test/schema_validator_test.cpp`

**Step 1: Write failing test**

Create `example/dbwriter/test/schema_validator_test.cpp`:

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/schema_validator.hpp"
#include "dbwriter/table.hpp"
#include "dbwriter/pg_types.hpp"
#include "test/mock_database.hpp"
#include <gtest/gtest.h>
#include <gmock/gmock.h>

namespace dbwriter {
namespace {

constexpr auto test_table = Table{"test",
    Column<"id", int64_t, pg::BigInt>{},
    Column<"name", std::string_view, pg::Text>{},
};

TEST(SchemaValidatorTest, ModeEnum) {
    EXPECT_NE(static_cast<int>(SchemaValidator::Mode::Strict),
              static_cast<int>(SchemaValidator::Mode::Warn));
    EXPECT_NE(static_cast<int>(SchemaValidator::Mode::Warn),
              static_cast<int>(SchemaValidator::Mode::Bootstrap));
}

}  // namespace
}  // namespace dbwriter
```

**Step 2: Implement schema_validator.hpp**

Create `example/dbwriter/include/dbwriter/schema_validator.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include "dbwriter/database.hpp"
#include <asio/awaitable.hpp>
#include <string>
#include <vector>

namespace dbwriter {

struct SchemaMismatch {
    std::string column;
    std::string expected;
    std::string actual;
};

class SchemaValidator {
public:
    enum class Mode {
        Strict,     // Fail if any mismatch
        Warn,       // Log warnings, continue
        Bootstrap,  // Create table if missing
    };

    template <typename Table>
    asio::awaitable<std::vector<SchemaMismatch>> validate(
            IDatabase& db, const Table& table, Mode mode);

    template <typename Table>
    asio::awaitable<void> ensure_table(IDatabase& db, const Table& table);

    template <typename Table>
    std::string create_table_sql(const Table& table);
};

// Template implementations would go here or in a .ipp file

}  // namespace dbwriter
```

**Step 3: Add test target and run**

**Step 4: Commit**

```bash
git add example/dbwriter/
git commit -m "feat(dbwriter): add SchemaValidator"
```

---

## Task 11: AsioEventLoop Implementation

**Files:**
- Create: `example/dbwriter/include/dbwriter/asio_event_loop.hpp`
- Create: `example/dbwriter/test/asio_event_loop_test.cpp`

**Step 1: Write failing test**

Create `example/dbwriter/test/asio_event_loop_test.cpp`:

```cpp
// SPDX-License-Identifier: MIT

#include "dbwriter/asio_event_loop.hpp"
#include <gtest/gtest.h>

namespace dbwriter {
namespace {

TEST(AsioEventLoopTest, ConstructsWithContext) {
    asio::io_context ctx;
    AsioEventLoop loop(ctx);

    SUCCEED();
}

TEST(AsioEventLoopTest, DeferExecutesCallback) {
    asio::io_context ctx;
    AsioEventLoop loop(ctx);

    bool called = false;
    loop.Defer([&] { called = true; });

    ctx.run();

    EXPECT_TRUE(called);
}

TEST(AsioEventLoopTest, ScheduleExecutesAfterDelay) {
    asio::io_context ctx;
    AsioEventLoop loop(ctx);

    bool called = false;
    loop.Schedule(std::chrono::milliseconds(10), [&] { called = true; });

    ctx.run();

    EXPECT_TRUE(called);
}

}  // namespace
}  // namespace dbwriter
```

**Step 2: Implement asio_event_loop.hpp**

Create `example/dbwriter/include/dbwriter/asio_event_loop.hpp`:

```cpp
// SPDX-License-Identifier: MIT

#pragma once

#include <asio.hpp>
#include <chrono>
#include <functional>
#include <memory>
#include <thread>
#include <unordered_map>

namespace dbwriter {

// Matches dbn_pipe::IEventLoop interface
class AsioEventLoop {
public:
    using ReadCallback = std::function<void()>;
    using WriteCallback = std::function<void()>;
    using ErrorCallback = std::function<void(int)>;
    using TimerCallback = std::function<void()>;

    explicit AsioEventLoop(asio::io_context& ctx)
        : ctx_(ctx)
        , thread_id_(std::this_thread::get_id()) {}

    void Run() { ctx_.run(); }
    void Stop() { ctx_.stop(); }

    void Defer(std::function<void()> fn) {
        asio::post(ctx_, std::move(fn));
    }

    void Schedule(std::chrono::milliseconds delay, TimerCallback fn) {
        auto timer = std::make_shared<asio::steady_timer>(ctx_, delay);
        timer->async_wait([timer, fn = std::move(fn)](auto ec) {
            if (!ec) fn();
        });
    }

    bool IsInEventLoopThread() const {
        return std::this_thread::get_id() == thread_id_;
    }

    template <typename Awaitable>
    void Spawn(Awaitable&& coro) {
        asio::co_spawn(ctx_, std::forward<Awaitable>(coro), asio::detached);
    }

    asio::io_context& context() { return ctx_; }

private:
    asio::io_context& ctx_;
    std::thread::id thread_id_;
};

}  // namespace dbwriter
```

**Step 3: Add test target and run**

**Step 4: Commit**

```bash
git add example/dbwriter/
git commit -m "feat(dbwriter): add AsioEventLoop implementation"
```

---

## Task 12: Integration Test with Testcontainers

**Files:**
- Create: `example/dbwriter/test/integration_test.cpp`

**Step 1: Write integration test**

Create `example/dbwriter/test/integration_test.cpp`:

```cpp
// SPDX-License-Identifier: MIT

// Note: This test requires Docker and a running PostgreSQL container
// Run with: bazel test //example/dbwriter:integration_test --test_env=POSTGRES_URL=...

#include "dbwriter/postgres.hpp"
#include "dbwriter/mapper.hpp"
#include "dbwriter/table.hpp"
#include "dbwriter/pg_types.hpp"
#include <gtest/gtest.h>

namespace dbwriter {
namespace {

class IntegrationTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Check for POSTGRES_URL environment variable
        const char* url = std::getenv("POSTGRES_URL");
        if (!url) {
            GTEST_SKIP() << "POSTGRES_URL not set, skipping integration tests";
        }
        // Parse URL and create config...
    }
};

TEST_F(IntegrationTest, DISABLED_CopyWritesData) {
    // This test requires a real PostgreSQL connection
    // Enable by removing DISABLED_ and setting POSTGRES_URL
    SUCCEED();
}

}  // namespace
}  // namespace dbwriter
```

**Step 2: Add test target**

Add to BUILD.bazel with appropriate tags to skip by default.

**Step 3: Commit**

```bash
git add example/dbwriter/
git commit -m "test(dbwriter): add integration test scaffold"
```

---

## Summary

Tasks completed:
1. Project structure and basic types
2. PostgreSQL binary type encoders
3. FixedString for column names
4. Column and Table schema definitions
5. Mapper for binary row encoding
6. Database interface and mocks
7. Transform layer
8. PostgreSQL CopyWriter
9. BatchWriter with backpressure
10. Schema validator
11. AsioEventLoop
12. Integration test scaffold

Each task follows TDD with:
- Write failing test
- Implement minimal code
- Verify test passes
- Commit
